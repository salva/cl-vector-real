(defun ^ (&rest args)
  (let* ((n (length args))
         (v (make-array n :element-type 'long-float :initial-element 0d0)))
    (do ((args args (cdr args))
         (i 0 (1+ i)))
        ((null args) v)
      (setf (aref v i) (coerce (car args) 'long-float)))))

(defun ^-copy (v)
  (declare (type (vector long-float) v))
  (let* ((n (length v)))
    (make-array n :element-type 'long-float :initial-contents v)))

(defun ^-make (n)
  (make-array n :element-type 'long-float))

(defun ^-make-zero (n)
  (make-array n :element-type 'long-float :initial-element 0.0d0))

(defun ^-make-cube (n c)
  (let ((c-lf (coerce c 'long-float)))
    (make-array n :element-type 'long-float :initial-element c-lf)))

(defun ^-axis-versor (n axis)
  (let ((v (^-make-zero n)))
    (setf (aref v axis) 1.0d0)
    v))

(defun ^-dim (v)
  (declare (type (vector long-float) v))
  (length v))

(defun ^-assert-dim (dim v)
  (declare (type (vector long-float) v))
  (unless (= dim (^-dim v))
    (throw 'vectors-dimension-mismatch 0)))

(defun ^-assert-dim-list (dim vs)
  (dolist (v vs dim)
    (^-assert-dim dim v)))

(declaim (inline ^-dim-and-assert-compat))
(defun ^-dim-and-assert-compat (v &rest vs)
  (^-assert-dim-list (^-dim v) vs))

(defun ^-inc-2 (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1)))
    (dotimes (i n v0)
      (incf (aref v0 i) (aref v1 i)))))

(defun ^-inc-list (v vs)
  (declare (type (vector long-float) v))
  (dolist (v1 vs v)
    (^-inc-2 v v1)))

(defun ^-inc (v &rest vs)
  (^-inc-list v vs))

(defun ^-dec-2 (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1)))
    (dotimes (i n v0)
      (decf (aref v0 i) (aref v1 i)))))

(defun ^-dec-list (v vs)
  (declare (type (vector long-float) v))
  (dolist (v1 vs v)
    (^-dec-2 v v1)))

(defun ^-dec (v &rest vs)
  (^-dec-list v vs))

(defun ^+-2 (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1))
         (r (^-make n)))
    (dotimes (i n r)
      (setf (aref r i) (+ (aref v0 i) (aref v1 i))))))

(declaim (inline ^+-list))
(defun ^+-list (v vs)
  (declare (type (vector long-float) v))
  (if vs
      (let ((r (^+-2 v (car vs))))
        (^-inc-list r (cdr vs)))
      (^-copy v)))

(declaim (inline ^+))
(defun ^+ (v &rest vs)
  (^+-list v vs))

(defun ^--2 (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1))
         (r (^-make n)))
    (dotimes (i n r)
      (setf (aref r i) (- (aref v0 i) (aref v1 i))))))

(defun ^--list (v vs)
  (declare (type (vector long-float) v))
  (if vs
      (let ((r (^--2 v (car vs))))
        (^-dec-list r (cdr vs)))
      (^-copy v)))

(declaim (inline ^-))
(defun ^- (v &rest vs)
  (^--list v vs))

(defun ^. (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1))
         (r 0))
    (dotimes (i n r)
      (incf r (* (aref v0 i) (aref v1 i))))))

(defun ^* (s v)
    (declare (type (vector long-float) v))
    (let* ((n (^-dim v))
           (r (^-make n))
           (s-lf (coerce s 'long-float)))
      (dotimes (i n r)
        (setf (aref r i) (* s-lf (aref v i))))))

(defun ^-set (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1)))
    (dotimes (i n v0)
      (setf (aref v0 i) (aref v1 i)))))

(defun ^-inc-scaled (v0 v1 s)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let* ((n (^-dim-and-assert-compat v0 v1))
         (s-lf (coerce s 'long-float)))
    (dotimes (i n v0)
      (incf (aref v0 i) (* s-lf (aref v1 i))))))

(defun ^-scale (v0 s)
  (declare (type (vector long-float) v0))
  (let* ((n (^-dim v0))
         (s-lf (coerce s 'long-float)))
    (dotimes (i n v0)
      (setf (aref v0 i) (* s-lf (aref v0 i))))))

(defun ^-norm2 (v)
  (declare (type (vector long-float) v))
  (let ((n (^-dim v))
        (d2 0.0d0))
    (dotimes (i n d2)
      (let ((c (aref v i)))
        (incf d2 (* c c))))))

(defun ^-norm (v)
  (sqrt (^-norm2 v)))

(defun ^-norm-chebyshev (v)
  (declare (type (vector long-float) v))
  (let ((n (^-dim v))
        (d 0.0d0)
        (ix 0))
    (dotimes (i n (values d ix))
      (let ((c (abs (aref v i))))
        (when (> c d)
          (setf d c ix i))))))

(defun ^-norm-manhattan (v)
  (declare (type (vector long-float) v))
  (let ((n (^-dim v))
        (d 0.0d0))
    (dotimes (i n d)
      (incf d (abs (aref v i))))))

(defun ^-dist2 (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let ((n (^-dim-and-assert-compat v0 v1))
        (d2 0.0d0))
    (dotimes (i n d2)
      (let ((delta (- (aref v0 i) (aref v1 i))))
        (incf d2 (* delta delta))))))

(defun ^-dist (v0 v1)
  (sqrt (^-dist2 v0 v1)))

(defun ^-dist-chebyshev (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let ((n (^-dim-and-assert-compat v0 v1))
        (d 0.0d0)
        (ix 0))
    (dotimes (i n (values d ix))
      (let ((delta (abs (- (aref v0 i) (aref v1 i)))))
        (when (> delta d)
          (setf d delta ix i))))))

(defun ^-dist-manhattan (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let ((n (^-dim-and-assert-compat v0 v1))
        (d 0.0d0))
    (dotimes (i n d)
      (incf d (abs (- (aref v0 i) (aref v1 i)))))))

(defun ^= (v0 v1 &key epsilon)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (if epsilon
      (<= (^-dist2 v0 v1) (coerce epsilon 'long-float))
      (let ((n (^-dim-and-assert-compat v0 v1)))
        (dotimes (i n t)
          (unless (= (aref v0 i) (aref v1 i))
            (return-from ^=))))))

(defun ^-versor (v)
  (^* v (/ 1.0d0 (^-norm v))))

(defun ^-versorize (v)
  (^-scale v (^-norm v)))

(defun ^-ang (v0 v1)
  (declare (type (vector long-float) v0)
           (type (vector long-float) v1))
  (let ((dot (^. v0 v1))
        (n20 (^-norm2 v0))
        (n21 (^-norm2 v1)))
    (acos (/ dot (sqrt (* n20 n21))))))
        
(defun ^-box (v &rest vs)
  (declare (type (vector long-float) v))
  (let* ((n (^-dim v))
         (min (^-copy v))
         (max (^-copy v)))
    (dolist (v1 vs (values min max))
      (dotimes (i n)
        (let ((c (aref v1 i)))
          (if (< c (aref min i))
              (setf (aref min i) c)
              (if (> c (aref max i))
                  (setf (aref max i) c))))))))
